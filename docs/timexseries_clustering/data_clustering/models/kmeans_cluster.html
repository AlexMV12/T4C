<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>timexseries_clustering.data_clustering.models.kmeans_cluster API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>timexseries_clustering.data_clustering.models.kmeans_cluster</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import itertools
import json
import pkgutil
import logging
import os
import numpy as np
import pandas as pd

from tslearn.clustering import TimeSeriesKMeans
from tslearn.datasets import CachedDatasets
from tslearn.preprocessing import TimeSeriesScalerMeanVariance, TimeSeriesResampler
from pandas import DataFrame
from tslearn.clustering import TimeSeriesKMeans, silhouette_score
from timexseries_clustering.data_clustering.models.predictor import ModelResult, SingleResult
from timexseries_clustering.data_clustering.validation_performances import ValidationPerformance
from timexseries_clustering.data_clustering import ClustersModel
from timexseries_clustering.data_clustering.transformation import transformation_factory

logging.getLogger(&#39;kMeansModel&#39;).setLevel(logging.WARNING)
log = logging.getLogger(__name__)


def KMeansModel(ingested_data: DataFrame, clustering_approach: str, distance_metric: str, 
                param_config: dict, transformation: str = None, n_clusters: int = 3)-&gt;ModelResult:
    &#34;&#34;&#34;
    K Means clustering model
    
    Parameters
    ----------
    clustering_approach : str
        Clustering approach, e.g. &#34;observation_based&#34;
    param_config : dict
        TIMEX configuration dictionary, to pass to the just created model.
    distance_metric : str, e.g. **
        Distance/similarity measure type, e.g. &#34;euclidean, dtw, softdtw&#34; **
    transformation : str, optional, default None
        Optional `transformation` parameter to pass to the just created model.
    n_clusters : int, optional, default 3
        Optional `number of clusters` parameter to pass to the just created model.
    
    Returns
    -------
    ModelResult
        Model Result of the class specified in `model_class`, it contains the 
        results of the best clustering with the index of the cluster that each 
        time series belongs to. Contains also the model characteristics and the 
        centers of each cluster.
    
    &#34;&#34;&#34;
    
    seed=0
    model_centers = []
    model_characteristics = {}
    
    try:
        gamma = param_config[&#34;model_parameters&#34;][&#34;gamma&#34;]
    except KeyError:
        gamma = 0.01
    try:
        pre_transformation = param_config[&#34;model_parameters&#34;][&#34;pre_transformation&#34;]
    except KeyError:
        pre_transformation = &#34;none&#34;
    
    if distance_metric == &#34;euclidean&#34;:
        km = TimeSeriesKMeans(n_clusters=n_clusters, metric=distance_metric, verbose=False, random_state=seed)
        best_clusters = km.fit_predict(ingested_data.copy().transpose())
        for yi in range(n_clusters):
            centrd = km.cluster_centers_[yi].ravel()
            model_centers.append(centrd)
        model_centers_dataframe = pd.DataFrame(model_centers).T
        model_centers_dataframe = model_centers_dataframe.set_index(ingested_data.index.date)
        inverse_pre_transf = transformation_factory(pre_transformation)
        model_centers_dataframe = inverse_pre_transf.inverse(model_centers_dataframe.copy())
        model_characteristics[&#34;clustering_approach&#34;] = clustering_approach
        model_characteristics[&#34;model&#34;] = &#34;K Means&#34;
        model_characteristics[&#34;distance_metric&#34;] = &#34;Euclidean&#34;
        model_characteristics[&#34;n_clusters&#34;] = n_clusters
        model_characteristics[&#34;feature_transformation&#34;] = transformation
        model_characteristics[&#34;pre_transformation&#34;] = pre_transformation
        performance = ValidationPerformance()
        performance.set_performance_stats(ingested_data.transpose(), best_clusters, distance_metric)
        single_result = SingleResult(model_characteristics, performance)
        return ModelResult(best_clustering=best_clusters, results=[single_result],characteristics=model_characteristics,
                    cluster_centers=model_centers_dataframe)
    
    if distance_metric == &#34;dtw&#34;:
        km = TimeSeriesKMeans(n_clusters=n_clusters, metric=distance_metric, verbose=False, max_iter_barycenter=10, random_state=seed)
        best_clusters = km.fit_predict(ingested_data.copy().transpose())
        performance = float(silhouette_score(ingested_data.transpose(), best_clusters, metric=distance_metric))
        for yi in range(n_clusters):
            centrd = km.cluster_centers_[yi].ravel()
            model_centers.append(centrd)
        model_centers_dataframe = pd.DataFrame(model_centers).T
        model_centers_dataframe = model_centers_dataframe.set_index(ingested_data.index.date)
        inverse_pre_transf = transformation_factory(pre_transformation)
        model_centers_dataframe = inverse_pre_transf.inverse(model_centers_dataframe.copy())
        model_characteristics[&#34;clustering_approach&#34;] = clustering_approach
        model_characteristics[&#34;model&#34;] = &#34;K Means&#34;
        model_characteristics[&#34;distance_metric&#34;] = &#34;DTW&#34;
        model_characteristics[&#34;n_clusters&#34;] = n_clusters
        model_characteristics[&#34;feature_transformation&#34;] = transformation
        model_characteristics[&#34;pre_transformation&#34;] = pre_transformation
        performance = ValidationPerformance()
        performance.set_performance_stats(ingested_data.transpose(), best_clusters, distance_metric)
        single_result = SingleResult(model_characteristics,performance)
        return ModelResult(best_clustering=best_clusters, results=[single_result],characteristics=model_characteristics,
                    cluster_centers=model_centers_dataframe)
        
    if distance_metric == &#34;softdtw&#34;:
        km = TimeSeriesKMeans(n_clusters=n_clusters, metric=distance_metric, verbose=False, metric_params={&#34;gamma&#34;: gamma}, random_state=seed)
        best_clusters = km.fit_predict(ingested_data.copy().transpose())
        performance = float(silhouette_score(ingested_data.transpose(), best_clusters, metric=distance_metric))
        for yi in range(n_clusters):
            centrd = km.cluster_centers_[yi].ravel()
            model_centers.append(centrd)
        model_centers_dataframe = pd.DataFrame(model_centers).T
        model_centers_dataframe = model_centers_dataframe.set_index(ingested_data.index.date)
        inverse_pre_transf = transformation_factory(pre_transformation)
        model_centers_dataframe = inverse_pre_transf.inverse(model_centers_dataframe.copy())
        model_characteristics[&#34;clustering_approach&#34;] = clustering_approach
        model_characteristics[&#34;model&#34;] = &#34;K Means&#34;
        model_characteristics[&#34;distance_metric&#34;] = &#34;SoftDTW&#34;
        model_characteristics[&#34;n_clusters&#34;] = n_clusters
        model_characteristics[&#34;feature_transformation&#34;] = transformation
        model_characteristics[&#34;pre_transformation&#34;] = pre_transformation
        performance = ValidationPerformance()
        performance.set_performance_stats(ingested_data.transpose(), best_clusters, distance_metric)
        single_result = SingleResult(model_characteristics,performance)
        return ModelResult(best_clustering=best_clusters, results=[single_result],characteristics=model_characteristics,
                    cluster_centers=model_centers_dataframe)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="timexseries_clustering.data_clustering.models.kmeans_cluster.KMeansModel"><code class="name flex">
<span>def <span class="ident">KMeansModel</span></span>(<span>ingested_data: pandas.core.frame.DataFrame, clustering_approach: str, distance_metric: str, param_config: dict, transformation: str = None, n_clusters: int = 3) ‑> <a title="timexseries_clustering.data_clustering.models.predictor.ModelResult" href="predictor.html#timexseries_clustering.data_clustering.models.predictor.ModelResult">ModelResult</a></span>
</code></dt>
<dd>
<div class="desc"><p>K Means clustering model</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>clustering_approach</code></strong> :&ensp;<code>str</code></dt>
<dd>Clustering approach, e.g. "observation_based"</dd>
<dt><strong><code>param_config</code></strong> :&ensp;<code>dict</code></dt>
<dd>TIMEX configuration dictionary, to pass to the just created model.</dd>
<dt><strong><code>distance_metric</code></strong> :&ensp;<code>str, e.g. **</code></dt>
<dd>Distance/similarity measure type, e.g. "euclidean, dtw, softdtw" **</dd>
<dt><strong><code>transformation</code></strong> :&ensp;<code>str</code>, optional, default <code>None</code></dt>
<dd>Optional <code>transformation</code> parameter to pass to the just created model.</dd>
<dt><strong><code>n_clusters</code></strong> :&ensp;<code>int</code>, optional, default <code>3</code></dt>
<dd>Optional <code>number of clusters</code> parameter to pass to the just created model.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>ModelResult</code></dt>
<dd>Model Result of the class specified in <code>model_class</code>, it contains the
results of the best clustering with the index of the cluster that each
time series belongs to. Contains also the model characteristics and the
centers of each cluster.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def KMeansModel(ingested_data: DataFrame, clustering_approach: str, distance_metric: str, 
                param_config: dict, transformation: str = None, n_clusters: int = 3)-&gt;ModelResult:
    &#34;&#34;&#34;
    K Means clustering model
    
    Parameters
    ----------
    clustering_approach : str
        Clustering approach, e.g. &#34;observation_based&#34;
    param_config : dict
        TIMEX configuration dictionary, to pass to the just created model.
    distance_metric : str, e.g. **
        Distance/similarity measure type, e.g. &#34;euclidean, dtw, softdtw&#34; **
    transformation : str, optional, default None
        Optional `transformation` parameter to pass to the just created model.
    n_clusters : int, optional, default 3
        Optional `number of clusters` parameter to pass to the just created model.
    
    Returns
    -------
    ModelResult
        Model Result of the class specified in `model_class`, it contains the 
        results of the best clustering with the index of the cluster that each 
        time series belongs to. Contains also the model characteristics and the 
        centers of each cluster.
    
    &#34;&#34;&#34;
    
    seed=0
    model_centers = []
    model_characteristics = {}
    
    try:
        gamma = param_config[&#34;model_parameters&#34;][&#34;gamma&#34;]
    except KeyError:
        gamma = 0.01
    try:
        pre_transformation = param_config[&#34;model_parameters&#34;][&#34;pre_transformation&#34;]
    except KeyError:
        pre_transformation = &#34;none&#34;
    
    if distance_metric == &#34;euclidean&#34;:
        km = TimeSeriesKMeans(n_clusters=n_clusters, metric=distance_metric, verbose=False, random_state=seed)
        best_clusters = km.fit_predict(ingested_data.copy().transpose())
        for yi in range(n_clusters):
            centrd = km.cluster_centers_[yi].ravel()
            model_centers.append(centrd)
        model_centers_dataframe = pd.DataFrame(model_centers).T
        model_centers_dataframe = model_centers_dataframe.set_index(ingested_data.index.date)
        inverse_pre_transf = transformation_factory(pre_transformation)
        model_centers_dataframe = inverse_pre_transf.inverse(model_centers_dataframe.copy())
        model_characteristics[&#34;clustering_approach&#34;] = clustering_approach
        model_characteristics[&#34;model&#34;] = &#34;K Means&#34;
        model_characteristics[&#34;distance_metric&#34;] = &#34;Euclidean&#34;
        model_characteristics[&#34;n_clusters&#34;] = n_clusters
        model_characteristics[&#34;feature_transformation&#34;] = transformation
        model_characteristics[&#34;pre_transformation&#34;] = pre_transformation
        performance = ValidationPerformance()
        performance.set_performance_stats(ingested_data.transpose(), best_clusters, distance_metric)
        single_result = SingleResult(model_characteristics, performance)
        return ModelResult(best_clustering=best_clusters, results=[single_result],characteristics=model_characteristics,
                    cluster_centers=model_centers_dataframe)
    
    if distance_metric == &#34;dtw&#34;:
        km = TimeSeriesKMeans(n_clusters=n_clusters, metric=distance_metric, verbose=False, max_iter_barycenter=10, random_state=seed)
        best_clusters = km.fit_predict(ingested_data.copy().transpose())
        performance = float(silhouette_score(ingested_data.transpose(), best_clusters, metric=distance_metric))
        for yi in range(n_clusters):
            centrd = km.cluster_centers_[yi].ravel()
            model_centers.append(centrd)
        model_centers_dataframe = pd.DataFrame(model_centers).T
        model_centers_dataframe = model_centers_dataframe.set_index(ingested_data.index.date)
        inverse_pre_transf = transformation_factory(pre_transformation)
        model_centers_dataframe = inverse_pre_transf.inverse(model_centers_dataframe.copy())
        model_characteristics[&#34;clustering_approach&#34;] = clustering_approach
        model_characteristics[&#34;model&#34;] = &#34;K Means&#34;
        model_characteristics[&#34;distance_metric&#34;] = &#34;DTW&#34;
        model_characteristics[&#34;n_clusters&#34;] = n_clusters
        model_characteristics[&#34;feature_transformation&#34;] = transformation
        model_characteristics[&#34;pre_transformation&#34;] = pre_transformation
        performance = ValidationPerformance()
        performance.set_performance_stats(ingested_data.transpose(), best_clusters, distance_metric)
        single_result = SingleResult(model_characteristics,performance)
        return ModelResult(best_clustering=best_clusters, results=[single_result],characteristics=model_characteristics,
                    cluster_centers=model_centers_dataframe)
        
    if distance_metric == &#34;softdtw&#34;:
        km = TimeSeriesKMeans(n_clusters=n_clusters, metric=distance_metric, verbose=False, metric_params={&#34;gamma&#34;: gamma}, random_state=seed)
        best_clusters = km.fit_predict(ingested_data.copy().transpose())
        performance = float(silhouette_score(ingested_data.transpose(), best_clusters, metric=distance_metric))
        for yi in range(n_clusters):
            centrd = km.cluster_centers_[yi].ravel()
            model_centers.append(centrd)
        model_centers_dataframe = pd.DataFrame(model_centers).T
        model_centers_dataframe = model_centers_dataframe.set_index(ingested_data.index.date)
        inverse_pre_transf = transformation_factory(pre_transformation)
        model_centers_dataframe = inverse_pre_transf.inverse(model_centers_dataframe.copy())
        model_characteristics[&#34;clustering_approach&#34;] = clustering_approach
        model_characteristics[&#34;model&#34;] = &#34;K Means&#34;
        model_characteristics[&#34;distance_metric&#34;] = &#34;SoftDTW&#34;
        model_characteristics[&#34;n_clusters&#34;] = n_clusters
        model_characteristics[&#34;feature_transformation&#34;] = transformation
        model_characteristics[&#34;pre_transformation&#34;] = pre_transformation
        performance = ValidationPerformance()
        performance.set_performance_stats(ingested_data.transpose(), best_clusters, distance_metric)
        single_result = SingleResult(model_characteristics,performance)
        return ModelResult(best_clustering=best_clusters, results=[single_result],characteristics=model_characteristics,
                    cluster_centers=model_centers_dataframe)</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="timexseries_clustering.data_clustering.models" href="index.html">timexseries_clustering.data_clustering.models</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="timexseries_clustering.data_clustering.models.kmeans_cluster.KMeansModel" href="#timexseries_clustering.data_clustering.models.kmeans_cluster.KMeansModel">KMeansModel</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>